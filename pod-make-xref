#!/usr/bin/env perl

use v5.20;

use strict;
use warnings;

use lib 'lib';
use feature 'signatures';
no warnings 'experimental::signatures';

use Pod::XrefModules;

# binmode(STDOUT, ":utf8");

# Accepts a list of globs to be passed to Pod::Simple::Search.  If any
# item in the list (e.g., 'Mojo') does not contain any wildcards ('*'
# or '?'), that item will also be understood to include Pods in that
# tree (e.g., the glob 'Mojo::*').  An item can also be an explicit
# filename.

my @file_list;

#
# Handle switches:
#   -t <tag>       Tag this set of podpages in the database
#   -d <dbname>    Location of database file to use

# TODO:
#   * Default tagname as first module listed
#   * Select and automatically tag all local podfiles from
#     Pod::Simple::Search
#   * Retrieve and handle remote podfiles from URI
#   * Build a Minion job handler to do the above


use Getopt::Std;
my %opts;
getopts('t:d:', \%opts);
my $tag_pages = $opts{t};

#
# TODO: Use the .conf file
#
my $dbfile = $opts{d} // 'data/pod_index.db';

#
# TODO: Use (from the .conf file) an external URI source for other pods
#


#
# Remaining arguments are names of POD files, module names, or globs
# of module names.
#

push @file_list, @ARGV;

my $pods = Pod::XrefModules->new()->select(@file_list)->parse;

################
#
# Store structure in database
#
################

use Mojo::SQLite;
use Mojo::SQLite::Migrations;

if (defined $dbfile) {

    if (! -f $dbfile) {
        die "database $dbfile does not exist.  Create one like so:\n  sqlite3 $dbfile";
    }
    if (! -r $dbfile) {
        die "database $dbfile exists but is not readable.";
    }

    my $sql = Mojo::SQLite->new($dbfile);
    $sql->migrations->from_data->migrate;

    if(! $sql->db->ping) {
        die "Failed to open database $dbfile.";
    }

    my $db = $sql->db;

    #
    # TODO:
    #  - Move this into the main program ('app')
    #  - Tag name and podfile/module-name array are the arguments
    #  - Password-protect the functionality
    #


    # Save tags
    if ($tag_pages) {
        $db->delete('xref_tags', { name => $tag_pages });

        foreach my $pod_page ( keys %{$pods->podfiles()} ) {
            $db->insert('xref_tags', { name => $tag_pages, pod_page => $pod_page } );
        }
    }

    # Preliminary pass to delete all rows for modules which we have
    # processed, preventing duplicates.
    $db->delete('xref', { pod_page => [ keys %{$pods->podfiles()} ] });

    # Add the references to the database.
    foreach my $heading (keys %{$pods->references}) {
        foreach my $ref (@{$pods->references()->{$heading}}) {
            $db->insert('xref', { pod_page => $ref->{link},
                                  link_fragment => $ref->{link_fragment},
                                  link_type => $ref->{type},
                                  entry => $heading,
                                  cooked_entry => $ref->{cooked},
                                  raw_entry => $ref->{raw},
                                  sequence => $ref->{sequence}
                              });
        }
    }

    $sql->db->disconnect;
}

1;

__DATA__

@@xref_list.html.ep

Xref List text and code goes here

@@xref_get.html.ep

Xref Get stuff goes here
%=$id

@@migrations
-- 1 up

create table xref (
    id INTEGER PRIMARY KEY,
    link_type text,
    entry text,
    raw_entry text,
    cooked_entry text,
    pod_page text,
    link_fragment text,
    sequence integer
);

-- 1 down

drop table references;

-- 2 up

create table xref_tags (
    id INTEGER PRIMARY KEY,
    name text,
    pod_page text
);

-- 2 down

drop table xref_tags;
