#!/usr/bin/env perl

use v5.20;

use strict;
use warnings;

use lib 'lib';
use feature 'signatures';
no warnings 'experimental::signatures';

use Pod::Definitions;

binmode(STDOUT, ":utf8");

# Accepts a list of globs to be passed to Pod::Simple::Search.  If any
# item in the list (e.g., 'Mojo') does not contain any wildcards ('*'
# or '?'), that item will also be understood to include Pods in that
# tree (e.g., the glob 'Mojo::*').  An item can also be an explicit
# filename.

use Pod::Simple::Search;

my @file_list;

# TODO: Perhaps use one of the Getopt modules to handle switches, etc.

push @file_list, @ARGV;

my @pods;

sub parse_a_file ($filename, $podname) {
    my $pod_file = Pod::Definitions->new();

    $pod_file->parse_file($filename, $podname);

    push @pods, $pod_file;
}

foreach my $parse_file (@file_list) {
    # TODO: 2020-10-11 Verify operation with UTF-8 pods.
    if ($parse_file =~ /\./) { # Looks like a filename
        parse_a_file($parse_file, undef);
    } else {
        # Treat argument as a glob
        Pod::Simple::Search->new()->limit_glob($parse_file)->callback(\&parse_a_file)->survey();
        if ($parse_file !~ /[*?]/) { # Without explicit glob wildcards, default also to scanning ::*
            Pod::Simple::Search->new()->limit_glob($parse_file.'::*')->callback(\&parse_a_file)->survey();
        }
    }
}

; $DB::single = 1;
print "Foo!";


################

sub convert_to_href_text ($human_text) {
    $human_text =~ s/(\s|\(|=|\[)/-/g;
    $human_text =~ s/([^a-zA-Z0-9_\-*:])//g;
    return $human_text;
}

# sub convert_local_path_to_href ($file) {
#     $file =~ s{\..+}{}g;
#     $file =~ s{/}{::}g;
#     return $file;
# }








# use List::MoreUtils qw(uniq);

1;
