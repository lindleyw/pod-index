#!/usr/bin/env perl

use v5.20;

use strict;
use warnings;

use lib 'lib';
use feature 'signatures';
no warnings 'experimental::signatures';

use Pod::Definitions;

binmode(STDOUT, ":utf8");

# Accepts a list of globs to be passed to Pod::Simple::Search.  If any
# item in the list (e.g., 'Mojo') does not contain any wildcards ('*'
# or '?'), that item will also be understood to include Pods in that
# tree (e.g., the glob 'Mojo::*').  An item can also be an explicit
# filename.

use Pod::Simple::Search;

my @file_list;

# TODO: Perhaps use one of the Getopt modules to handle switches, etc.
#
# TODO:
#   -t <tag>       Tag this set of podpages in the database

use Getopt::Std;
my %opts;
getopts('t:', \%opts);
my $tag_pages = $opts{t};

push @file_list, @ARGV;

my @pods;
my @pod_files_processed;

sub parse_a_file ($filename, $podname) {

    push @pod_files_processed, $podname;

    my $pod_file = Pod::Definitions->new();

    $pod_file->parse_file($filename, $podname);

    push @pods, $pod_file;
}

foreach my $parse_file (@file_list) {
    # TODO: 2020-10-11 Verify operation with UTF-8 pods.
    if ($parse_file =~ /\./) { # Looks like a filename
        parse_a_file($parse_file, undef);
    } else {
        # Treat argument as a glob
        Pod::Simple::Search->new()->limit_glob($parse_file)->callback(\&parse_a_file)->survey();
        if ($parse_file !~ /[*?]/) { # Without explicit glob wildcards, default also to scanning ::*
            Pod::Simple::Search->new()->limit_glob($parse_file.'::*')->callback(\&parse_a_file)->survey();
        }
    }
}

################
#
# Cross-reference logic
#
# These assume the English language.  We do not attempt to parse
# English generally, only the technical subset typically used in Pod
# documentation of Perl modules in CPAN.
#
# GOAL: Each definition (whether main entry, or under 'see' or 'see
# also', should point to its defined link in a copy of its source
# document.
#
################

my $references = {};
my $see = {};
my $see_also = {};

#
# Begin to make a cross-reference, by pointing each subheading back to
# its container.
#
foreach my $pod (@pods) {
    next unless defined $pod->sections();
    foreach my $section (keys %{$pod->sections()}) {
        foreach my $definition (@{$pod->sections->{$section}}) {
            push @{$references->{$definition->{cooked}}}, $definition;
            # Each main key in the references (e.g., "FUNCTIONS")
            # should generate a "see..." entry for its entries:
            push @{$see->{$section}{$definition->{cooked}}}, $definition;
        }
    }
}

#
# Additionally, for entries that look like:
#
#    insert_thing_here
#
# 'thing' and 'here' will each obtain a "See also" to
# insert_thing_here, assuming 'thing' and 'here' are already main
# entries.
#
foreach my $heading (keys %{$references}) {
    my @subwords = split ( '_', $heading );
    next unless scalar @subwords > 1;
    shift @subwords;  # Ignore first word
    foreach my $subword ( @subwords ) {
        if (exists $references->{$subword}) {
            push @{$see_also->{$subword}}, @{$references->{$heading}};
        }
    }
}

# NOT_DONE:
# Alternately, the above may benefit from "See also" to "thing" and
# "here" if those words appear as main entries in the cross-reference.
#

#
# Furthermore, add cross-references ("See...") as follows:
#
#    Searching in sorted lists     -> Sorted lists, searching in
#    Counting and calculation      -> Calculation, counting and
#    Operations on sorted lists    -> Sorted lists, operations on
#    Treatment of an empty list    -> Empty list, treatment of
#    Help with a concrete version  -> Concrete version, help with
#

foreach my $heading (keys %{$references}) {
    my $raw = $heading;                      # Cook the heading below
    $heading =~ s/\buse\s+case\b/use-case/;  # special case for "use" as an adjective
    $heading =~ s/\s+with\s+this\s*\z//;     # ignore "...with this" at end
    $heading =~ s/,.+\z//;                   # Ignore anything after a comma
    $heading =~ s/\w+ing\s+to//g;            # ignore, e.g., "trying to" 
    # 'la' here to capture 'a la'
    if ($heading =~ /^(.+?)((?:\s+(?:what|how|is|are|in|on|of|with|through|thru|a|an|the|it|I|I'm|la|can|do|use|using|format|way|so)\b)+)\s+(.+)\z/i) {
        my ($leading_words, $modifying_words, $keywords) = ($1, $2, $3);
        my $cooked = "$keywords, $leading_words$modifying_words";
        my @matched;
        foreach my $check_key (split /\s+/, $keywords) {
            next if $check_key =~ /\b(:?to|in|of)\b/;  # Ignore prepositions, etc.
            $check_key =~ s/[,.]//g;
            # print "  [$check_key]";
            if (exists $references->{$check_key}) {
                push @matched, $check_key;
            } elsif (exists $references->{lc($check_key)}) {
                push @matched, lc($check_key);
            }
        }
        # If none of the above keywords matched an existing entry, use the cooked text.
        push @matched, $cooked unless (scalar @matched);
        foreach my $m (@matched) {
            push @{$see->{$m}{$raw}}, @{$references->{$raw}};
        }
    }
}

#
# TODO:
#
# If Pod::Definitions is updated to save links within the L<> elements
# in the See Also sections, and if the cross-references generated here
# are maintained in a database, it might be useful to add a main entry
# for each module name, with "See Also" links either as given (in the
# case of L<> pointing to a website) or internally to whatever website
# is hosting these cross-references (being mindful not to create links
# to xref documents which do not exist).
#

#
# Merge the See and See-Also tables into the main references entries
#
foreach my $source (keys %{$see}) {
    foreach my $heading (keys %{$see->{$source}}) {
        my @see_links = @{$see->{$source}{$heading}};
        my @add_links;
        foreach my $l (@see_links) {
            push @add_links, { %{$l}, type => 'see' };
        }
        push @{$references->{$source}}, @add_links;
    }
}

foreach my $source (keys %{$see_also}) {
    my @links = @{$see_also->{$source}};
    my @add_links;
    foreach my $l (@links) {
        push @add_links, { %{$l}, type => 'see-also' };
    }
    push @{$references->{$source}}, @add_links;
}

################
#
# Store structure in database
#
################

use Mojo::SQLite;
use Mojo::SQLite::Migrations;

my $dbfile = 'data/pod_index.db';

if (defined $dbfile) {

    # TODO, WL 2020-10-09
    # * Actually define Migrations and populate a useful database
    # * Put the logic into Serialize / Storable methods in the objects

    if (! -f $dbfile) {
        die "database $dbfile does not exist.  Create one like so:\n  sqlite3 $dbfile";
    }
    if (! -r $dbfile) {
        die "database $dbfile exists but is not readable.";
    }

    my $sql = Mojo::SQLite->new($dbfile);
    $sql->migrations->from_data->migrate;

    if(! $sql->db->ping) {
        die "Failed to open database $dbfile.";
    }

    my $db = $sql->db;

    # Save tags
    if ($tag_pages) {
        $db->delete('xref_tags', { name => $tag_pages });

        foreach my $pod_page (@pod_files_processed) {
            $db->insert('xref_tags', { name => $tag_pages, pod_page => $pod_page } );
        }
    }

    # Preliminary pass to delete all rows for modules which we have
    # processed, preventing duplicates.
    $db->delete('xref', { pod_page => \@pod_files_processed });

    # Add the references to the database.
    foreach my $heading (keys %{$references}) {
        foreach my $ref (@{$references->{$heading}}) {
            $db->insert('xref', { pod_page => $ref->{link},
                                  link_fragment => $ref->{link_fragment},
                                  link_type => $ref->{type},
                                  entry => $heading,
                                  cooked_entry => $ref->{cooked},
                                  raw_entry => $ref->{raw}
                              });
        }
    }

    $sql->db->disconnect;
}


#
# TODO:
#
# Maintain a database of official Pod documentation sources, e.g.,
#
#   https://metacpan.org/pod/
#
# to which our links may be appended, and at which the user may choose
# to point.  For example, it may be useful to point references within
# Mojo and Mojolicious to https://docs.mojolicious.org ... However,
# determining which documents exist there (for example, List::Utils
# does not) is not defined here.

my $link_base = 'https://metacpan.org/pod/';



1;


__DATA__


@@migrations
-- 1 up

create table xref (
    pod_page text,
    link_fragment text,
    link_type text,
    entry text,
    cooked_entry text,
    raw_entry text
);

-- 1 down

drop table references;

-- 2 up

create table xref_tags (
    name text,
    pod_page text
);

-- 2 down

drop table xref_tags;
